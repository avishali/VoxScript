================================================================================
MISSION: PHASE_III_ARA_AUDIO_EXTRACTION_001
================================================================================

CREATED: 2026-01-21
AUTHOR: Avishay Lidani (MelechDSP)
PROJECT: VoxScript
PHASE: III - Automatic Transcription Triggering

================================================================================
MULTI-AGENT MODE: ENABLED
================================================================================

This mission MUST be executed using the MULTI_AGENT_EXECUTION_V1 runbook.

EXECUTION SEQUENCE:
1. IMPLEMENTER makes code changes, writes IMPLEMENTER_RESULT.md, STOPS
2. VERIFIER audits changes, runs build, writes VERIFIER_RESULT.md + LAST_RESULT.md, STOPS
3. ARCHITECT reviews LAST_RESULT.md and approves/rejects

NO DEVIATION FROM THIS SEQUENCE IS PERMITTED.

================================================================================
OBJECTIVE
================================================================================

Enable AUTOMATIC TRANSCRIPTION when audio is added to the DAW by:

1. Creating AudioExtractor class to extract audio from ARA persistent sample access
2. Converting ARA audio samples to temporary 16kHz mono WAV files
3. Triggering WhisperEngine transcription automatically when audio source added
4. Managing temporary file lifecycle (create â†’ transcribe â†’ cleanup)
5. Updating UI to show transcription progress and results automatically

WHAT THIS MISSION IS:
âœ“ Completing the FIXME sections from Phase II (lines 74-90, 119-138 in VoxScriptDocumentController.cpp)
âœ“ Enabling end-to-end automatic transcription workflow
âœ“ Connecting ARA audio access to WhisperEngine processing
âœ“ Making VoxScript work as originally envisioned (drag audio â†’ see transcription)

WHAT THIS MISSION IS NOT:
âœ— NOT implementing text editing (deferred to later Phase III missions)
âœ— NOT implementing SOFA alignment (deferred to later Phase III missions)
âœ— NOT implementing waveform visualization (Phase IV)
âœ— NOT implementing model selection UI (Phase IV)

================================================================================
CONTEXT - PHASE II STATE
================================================================================

Phase II delivered a complete but INCOMPLETE transcription system:

WHAT WORKS (Phase II Complete):
âœ“ WhisperEngine can transcribe audio files (tested)
âœ“ VoxSequence stores transcription results correctly
âœ“ ScriptView displays transcription text when provided
âœ“ Thread-safe architecture with background processing
âœ“ Status updates work ("Transcribing: X%")
âœ“ Plugin loads in Reaper successfully

WHAT DOESN'T WORK (Phase II Gaps):
âœ— No automatic transcription triggering when audio added
âœ— User must manually call transcribeAudioFile() (no way to do this in UI)
âœ— FIXME comments at VoxScriptDocumentController.cpp lines 74-90, 119-138
âœ— No way to extract audio data from ARA persistent sample API

RESEARCH COMPLETED:
âœ“ Gemini 2.0 Flash Pro researched correct ARA API approach
âœ“ Production-ready AudioExtractor.h/.cpp files exist in PROMPTS/MISSIONS/
âœ“ Correct pattern: Use juce::ARAAudioSourceReader for thread-safe sample access
âœ“ Approach validated: Extract to temp WAV â†’ trigger transcription â†’ cleanup

ENTRY CRITERIA:
âœ“ Phase II runtime verification complete (plugin loads and works)
âœ“ Whisper model downloaded: ~/Library/Application Support/VoxScript/models/ggml-base.en.bin
âœ“ AudioExtractor implementation researched and ready
âœ“ ARCHITECT approval to proceed

================================================================================
SCOPE - FILES THAT MAY BE MODIFIED
================================================================================

NEW FILES (2 files):
  âœ“ Source/transcription/AudioExtractor.h
    - Class declaration for ARA audio extraction
    - Method to extract ARAAudioSource to temporary WAV file
    
  âœ“ Source/transcription/AudioExtractor.cpp
    - Implementation of audio extraction logic
    - Downmix to mono, resample to 16kHz, write to temp WAV
    - Thread-safe using local ARAAudioSourceReader

MODIFIED FILES (3 files):
  âœ“ Source/ara/VoxScriptDocumentController.h
    - Add AudioExtractor member
    - Add transcription lifecycle management methods
    
  âœ“ Source/ara/VoxScriptDocumentController.cpp
    - Remove FIXME comments at lines 74-90, 119-138
    - Implement automatic transcription triggering in didAddAudioSource()
    - Implement automatic transcription triggering in doCreatePlaybackRegion()
    - Add temp file cleanup after transcription
    
  âœ“ Source/ui/ScriptView.cpp
    - Connect to DocumentController to display transcription automatically
    - Ensure status updates trigger repaints

DOCUMENTATION (1 file):
  âœ“ CHANGELOG.md
    - Document Phase III Task 1 completion (audio extraction + auto-trigger)

TOTAL: 6 files (2 new, 4 modified)

================================================================================
SCOPE - FILES THAT MUST NOT BE MODIFIED
================================================================================

FORBIDDEN - DO NOT TOUCH:
  âœ— Source/transcription/WhisperEngine.h/cpp (works perfectly, no changes needed)
  âœ— Source/transcription/VoxSequence.h/cpp (works perfectly, no changes needed)
  âœ— Source/PluginProcessor.h/cpp (ARA factory must remain stable)
  âœ— Source/PluginEditor.h/cpp (dual-view layout is final)
  âœ— Source/ara/VoxScriptAudioSource.h/cpp (no changes needed for Phase III Task 1)
  âœ— Source/ara/VoxScriptPlaybackRenderer.h/cpp (Phase III Task 2, not this mission)
  âœ— Source/ui/DetailView.h/cpp (Phase IV)
  âœ— Source/ui/ScriptView.h (interface is complete, only .cpp needs minor updates)
  âœ— CMakeLists.txt (no new dependencies)
  âœ— build.sh (build script works, do not modify)
  âœ— Any build output directories
  âœ— Any JUCE source files

IF YOU THINK YOU NEED TO MODIFY A FORBIDDEN FILE:
â†’ STOP IMMEDIATELY
â†’ Write explanation in result file
â†’ Mission will be rejected, new mission will be created

================================================================================
AUDIOEXTRACTOR SPECIFICATION
================================================================================

REFERENCE IMPLEMENTATION:
The complete, production-ready implementation exists in:
  PROMPTS/MISSIONS/AudioExtractor.h
  PROMPTS/MISSIONS/AudioExtractor.cpp

IMPLEMENTER: You MUST use this reference implementation as-is or with only 
minor adaptations needed for VoxScript's specific setup.

KEY DESIGN DECISIONS (from Gemini 2.0 Flash Pro research):

1. THREAD SAFETY APPROACH:
   - Create LOCAL juce::ARAAudioSourceReader on worker thread
   - Do NOT share reader across threads (prevents Steinberg host glitches)
   - Worker thread owns entire extraction lifecycle

2. PERFORMANCE OPTIMIZATIONS:
   - Downmix to mono BEFORE resampling (50% CPU savings)
   - Use chunk-based processing (8192 samples per chunk)
   - Lagrange interpolation for resampling (good speed/quality balance)

3. WHISPER-OPTIMIZED OUTPUT:
   - Output format: 16kHz, mono, 16-bit PCM WAV
   - Matches whisper.cpp requirements exactly
   - No manual conversion needed before transcription

4. ERROR HANDLING:
   - Validates at every step (reader creation, writer creation, sample ranges)
   - Aborts gracefully on failure, cleans up resources
   - Returns empty File() on error (caller checks File::existsAsFile())

CLASS INTERFACE (AudioExtractor.h):

```cpp
#pragma once
#include <JuceHeader.h>

/**
 * Extracts audio from ARA persistent sample access to a temporary WAV file
 * optimized for whisper.cpp transcription (16kHz mono).
 */
class AudioExtractor
{
public:
    AudioExtractor();
    ~AudioExtractor();
    
    /**
     * Extract audio from an ARA audio source to a temporary WAV file.
     * 
     * @param araAudioSource The ARA audio source to extract from
     * @param prefix Optional prefix for temp filename (default: "voxscript_")
     * @return Temporary WAV file, or invalid File() on error
     * 
     * Output format: 16kHz mono, 16-bit PCM WAV (optimized for whisper.cpp)
     * 
     * Thread safety: Safe to call from any thread. Creates local ARAAudioSourceReader
     * to avoid sharing reader instances across threads (prevents Steinberg glitches).
     * 
     * Lifecycle: Caller is responsible for deleting the temp file after use.
     */
    juce::File extractToTempWAV(juce::ARAAudioSource* araAudioSource, 
                                const juce::String& prefix = "voxscript_");
    
private:
    juce::File getTempDirectory();
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(AudioExtractor)
};
```

IMPLEMENTATION REQUIREMENTS (AudioExtractor.cpp):

1. getTempDirectory():
   - Return juce::File::getSpecialLocation(juce::File::tempDirectory)
   - Or use ~/Library/Application Support/VoxScript/temp/ for persistence

2. extractToTempWAV():
   Step 1: Create local ARAAudioSourceReader on current thread
   Step 2: Get audio properties (sample rate, channel count, total samples)
   Step 3: Create temp WAV file with unique name (prefix + UUID + ".wav")
   Step 4: Create juce::WavAudioFormat writer (16kHz mono, 16-bit PCM)
   Step 5: Downmix to mono if multi-channel (average all channels)
   Step 6: Resample to 16kHz using Lagrange interpolation
   Step 7: Write samples to WAV file in chunks (8192 samples at a time)
   Step 8: Close writer and return File
   
   Error handling:
   - If reader creation fails â†’ return File()
   - If writer creation fails â†’ return File()
   - If sample reading fails â†’ delete temp file, return File()

CRITICAL THREAD SAFETY PATTERN:
```cpp
// CORRECT - create local reader on worker thread
auto reader = araAudioSource->createAudioSourceReader();
if (!reader) return juce::File(); // Error

// Use reader to extract samples...
// Reader automatically destroyed when function exits
```

DO NOT:
```cpp
// WRONG - sharing reader across threads causes Steinberg glitches
this->sharedReader = araAudioSource->createAudioSourceReader();
```

================================================================================
VOXSCRIPTDOCUMENTCONTROLLER INTEGRATION
================================================================================

CURRENT STATE (Phase II with FIXMEs):

VoxScriptDocumentController.cpp lines 74-90:
```cpp
void VoxScriptDocumentController::didAddAudioSource(ARA::PlugIn::AudioSource* audioSource)
{
    DBG("VoxScriptDocumentController::didAddAudioSource called");
    
    auto* voxAudioSource = static_cast<VoxScriptAudioSource*>(audioSource);
    DBG("Audio source added: " + juce::String(voxAudioSource->getAudioSource()->getName()));
    
    // FIXME Phase III: Extract audio from ARA persistent sample access
    // FIXME Phase III: Create temp WAV file: AudioExtractor.extractToTempWAV()
    // FIXME Phase III: Trigger transcription: whisperEngine.transcribeAudioFile(tempFile)
    // FIXME Phase III: Store temp file path for cleanup after transcription
}
```

VoxScriptDocumentController.cpp lines 119-138:
```cpp
ARA::PlugIn::PlaybackRegion* VoxScriptDocumentController::doCreatePlaybackRegion(
    ARA::PlugIn::AudioModification* audioModification)
{
    DBG("VoxScriptDocumentController::doCreatePlaybackRegion called");
    
    auto* playbackRegion = new VoxScriptPlaybackRenderer(this, audioModification);
    
    // FIXME Phase III: Consider triggering transcription here instead of didAddAudioSource()
    // FIXME Phase III: Might be more appropriate timing - region created when audio actually used
    // FIXME Phase III: Would need to check if transcription already done for this audio source
    
    return playbackRegion;
}
```

TARGET STATE (Phase III Complete):

MODIFICATIONS TO VoxScriptDocumentController.h:

```cpp
#include "transcription/AudioExtractor.h"

class VoxScriptDocumentController : public juce::ARADocumentControllerSpecialisation,
                                     private WhisperEngine::Listener
{
public:
    // ... existing methods ...
    
private:
    // WhisperEngine::Listener overrides (already implemented in Phase II)
    void transcriptionProgress (float progress) override;
    void transcriptionComplete (VoxSequence sequence) override;
    void transcriptionFailed (const juce::String& error) override;
    
    // NEW: Temp file management
    void cleanupTempFile();
    
    WhisperEngine whisperEngine;
    AudioExtractor audioExtractor;  // NEW
    VoxSequence currentTranscription;
    juce::String transcriptionStatus = "Idle";
    juce::File currentTempFile;     // NEW: Track temp file for cleanup
    
    // ... existing members ...
};
```

MODIFICATIONS TO VoxScriptDocumentController.cpp:

REMOVE FIXME comments and implement:

```cpp
void VoxScriptDocumentController::didAddAudioSource(ARA::PlugIn::AudioSource* audioSource)
{
    DBG("VoxScriptDocumentController::didAddAudioSource called");
    
    auto* voxAudioSource = static_cast<VoxScriptAudioSource*>(audioSource);
    auto* araAudioSource = voxAudioSource->getAudioSource();
    
    DBG("Audio source added: " + juce::String(araAudioSource->getName()));
    
    // Extract audio to temporary WAV file
    transcriptionStatus = "Extracting audio...";
    currentTempFile = audioExtractor.extractToTempWAV(araAudioSource);
    
    if (!currentTempFile.existsAsFile())
    {
        transcriptionStatus = "Failed: Could not extract audio";
        DBG("AudioExtractor failed to create temp file");
        return;
    }
    
    DBG("Audio extracted to: " + currentTempFile.getFullPathName());
    
    // Trigger transcription
    transcriptionStatus = "Starting transcription...";
    whisperEngine.transcribeAudioFile(currentTempFile);
}

void VoxScriptDocumentController::transcriptionComplete(VoxSequence sequence)
{
    currentTranscription = sequence;
    transcriptionStatus = "Ready";
    
    // Cleanup temp file after successful transcription
    cleanupTempFile();
    
    // Notify UI to display new transcription
    if (auto* editor = getEditorForAudioFile())
    {
        juce::MessageManager::callAsync([editor, sequence]()
        {
            if (auto* scriptView = editor->getScriptView())
            {
                scriptView->setTranscription(sequence);
                scriptView->setStatus("Ready");
            }
        });
    }
}

void VoxScriptDocumentController::transcriptionFailed(const juce::String& error)
{
    transcriptionStatus = "Failed: " + error;
    DBG("Transcription error: " + error);
    
    // Cleanup temp file after failed transcription
    cleanupTempFile();
}

void VoxScriptDocumentController::cleanupTempFile()
{
    if (currentTempFile.existsAsFile())
    {
        DBG("Deleting temp file: " + currentTempFile.getFullPathName());
        currentTempFile.deleteFile();
        currentTempFile = juce::File();
    }
}
```

DECISION: Use didAddAudioSource() NOT doCreatePlaybackRegion()
RATIONALE:
- didAddAudioSource() is called once when audio first added (correct timing)
- doCreatePlaybackRegion() may be called multiple times for same audio
- Avoid duplicate transcription work
- Matches user expectation: transcribe when audio dragged in

REMOVE the FIXME comments in doCreatePlaybackRegion() entirely:
```cpp
ARA::PlugIn::PlaybackRegion* VoxScriptDocumentController::doCreatePlaybackRegion(
    ARA::PlugIn::AudioModification* audioModification)
{
    DBG("VoxScriptDocumentController::doCreatePlaybackRegion called");
    return new VoxScriptPlaybackRenderer(this, audioModification);
}
```

================================================================================
SCRIPTVIEW UI CONNECTION
================================================================================

CURRENT STATE (Phase II):
ScriptView has setTranscription() and setStatus() methods, but they're not 
automatically called when DocumentController updates.

REQUIRED CHANGES (Minor):

ScriptView.cpp - Update paint() to handle transcription display better:

```cpp
void ScriptView::paint(juce::Graphics& g)
{
    g.fillAll(juce::Colours::white);
    
    // Draw status in top-left corner
    g.setColour(juce::Colours::grey);
    g.setFont(12.0f);
    g.drawText(statusText, 10, 10, 200, 20, juce::Justification::left);
    
    // Draw transcription text
    if (displayText.isNotEmpty())
    {
        g.setColour(juce::Colours::black);
        g.setFont(14.0f);
        auto textArea = getLocalBounds().reduced(20).withTrimmedTop(40);
        g.drawMultiLineText(displayText, textArea.getX(), textArea.getY(), 
                           textArea.getWidth());
    }
    else
    {
        g.setColour(juce::Colours::lightgrey);
        g.setFont(14.0f);
        g.drawText("Ready - Awaiting audio source", 
                   getLocalBounds(), juce::Justification::centred);
    }
}
```

ADD timer-based status polling (temporary solution for Phase III):
```cpp
// In ScriptView constructor:
startTimer(100); // Poll status every 100ms

// Add timerCallback() method:
void ScriptView::timerCallback()
{
    if (auto* docController = getDocumentController())
    {
        auto newStatus = docController->getTranscriptionStatus();
        if (newStatus != statusText)
        {
            setStatus(newStatus);
        }
        
        // Check if transcription updated
        auto& transcription = docController->getTranscription();
        if (!transcription.getSegments().isEmpty() && displayText.isEmpty())
        {
            setTranscription(transcription);
        }
    }
}
```

NOTE: Proper observer pattern is Phase IV work. Timer polling is acceptable for Phase III.

================================================================================
ACCEPTANCE CRITERIA
================================================================================

The mission is considered SUCCESSFUL if ALL of the following are true:

BUILD SYSTEM:
  [AC-1] Build completes without errors: `cd build-Debug && ninja`
  [AC-2] No new compiler warnings beyond existing JUCE warnings
  [AC-3] VST3 and Standalone formats build successfully

CODE STRUCTURE:
  [AC-4] Source/transcription/AudioExtractor.h exists and compiles
  [AC-5] Source/transcription/AudioExtractor.cpp exists and compiles
  [AC-6] AudioExtractor follows reference implementation from PROMPTS/MISSIONS/
  [AC-7] All new code follows JUCE naming conventions
  [AC-8] MelechDSP copyright header on new files

INTEGRATION:
  [AC-9] VoxScriptDocumentController.h includes AudioExtractor.h
  [AC-10] VoxScriptDocumentController has AudioExtractor member
  [AC-11] didAddAudioSource() calls audioExtractor.extractToTempWAV()
  [AC-12] didAddAudioSource() calls whisperEngine.transcribeAudioFile()
  [AC-13] transcriptionComplete() calls cleanupTempFile()
  [AC-14] transcriptionFailed() calls cleanupTempFile()
  [AC-15] FIXME comments REMOVED from lines 74-90
  [AC-16] FIXME comments REMOVED from lines 119-138

TEMP FILE MANAGEMENT:
  [AC-17] Temp WAV files created in appropriate directory
  [AC-18] Temp files have unique names (UUID-based)
  [AC-19] Temp files deleted after transcription success
  [AC-20] Temp files deleted after transcription failure
  [AC-21] No temp file leaks (verify /tmp or ~/Library/.../VoxScript/temp)

UI INTEGRATION:
  [AC-22] ScriptView updates automatically when transcription status changes
  [AC-23] ScriptView displays transcription text when complete
  [AC-24] UI does not freeze during extraction or transcription

RUNTIME BEHAVIOR (manual verification in VERIFIER step):
  [AC-25] Plugin loads in Reaper without crashing
  [AC-26] Drag audio file into Reaper â†’ "Extracting audio..." appears
  [AC-27] Status changes to "Transcribing: X%" with progress
  [AC-28] Transcription text appears in ScriptView after completion
  [AC-29] Multiple audio files can be transcribed sequentially
  [AC-30] Temp files cleaned up (verify temp directory empty after tests)

SCOPE COMPLIANCE:
  [AC-31] ZERO changes to WhisperEngine.h/cpp
  [AC-32] ZERO changes to VoxSequence.h/cpp
  [AC-33] ZERO changes to forbidden files
  [AC-34] ONLY files in scope list were modified

DOCUMENTATION:
  [AC-35] CHANGELOG.md updated with Phase III Task 1 completion

TOTAL: 35 acceptance criteria

ALL must PASS for mission success.
ANY failure = mission REJECTED, new mission created.

================================================================================
FORBIDDEN ACTIONS
================================================================================

DO NOT:
  âœ— Modify WhisperEngine.h/cpp (works perfectly, no changes needed)
  âœ— Modify VoxSequence.h/cpp (works perfectly, no changes needed)
  âœ— Implement text editing (later Phase III mission)
  âœ— Implement SOFA alignment (later Phase III mission)
  âœ— Implement waveform visualization (Phase IV)
  âœ— Add model selection UI (Phase IV)
  âœ— Add cancellation UI (Phase IV)
  âœ— Implement queue for multiple files (Phase IV)
  âœ— Add extraction progress callbacks (Phase IV)
  âœ— Implement proper observer pattern for UI updates (Phase IV)
  âœ— Refactor existing code beyond what's needed
  âœ— Add third-party dependencies
  âœ— Change plugin name, manufacturer code, or version

IF YOU ARE TEMPTED TO DO ANY OF THE ABOVE:
â†’ Stop and document in result file
â†’ Mission scope is fixed, no negotiation

================================================================================
BUILD VERIFICATION COMMAND
================================================================================

VERIFIER must run the following command and include output in VERIFIER_RESULT.md:

```bash
cd /Users/avishaylidani/DEV/GitHubRepo/VoxScript/build-Debug
ninja -v 2>&1 | tee build-phase3.log
```

Expected output: "[100%] Built target VoxScript_VST3" with no errors.

If build fails:
- Include first 50 lines of error output in VERIFIER_RESULT.md
- Mark all affected acceptance criteria as FAIL
- Mission is REJECTED

================================================================================
RUNTIME VERIFICATION STEPS
================================================================================

VERIFIER must perform these manual tests IN ORDER:

1. CLEAN START:
   - Delete any existing temp files: rm -rf /tmp/voxscript_*.wav
   - Verify model exists: ~/Library/Application Support/VoxScript/models/ggml-base.en.bin
   - Record: Environment clean? (PASS/FAIL)

2. PLUGIN LOAD TEST:
   - Open Reaper
   - Create audio track
   - Add VoxScript as ARA extension
   - Record: Plugin loads without crash? (PASS/FAIL)

3. AUTO-TRANSCRIPTION TEST:
   - Drag audio file into Reaper track (use short file, 10-30 seconds)
   - Observe VoxScript UI immediately
   - Record: Shows "Extracting audio..." status? (PASS/FAIL)
   - Wait 2-5 seconds
   - Record: Status changes to "Transcribing: X%"? (PASS/FAIL)
   - Wait for completion
   - Record: Transcription text appears in ScriptView? (PASS/FAIL)

4. TEMP FILE CLEANUP TEST:
   - After test 3 completes, check temp directory:
     ls /tmp/voxscript_*.wav
   - Record: Temp files deleted? (PASS/FAIL)

5. MULTI-FILE TEST:
   - Drag second audio file into Reaper
   - Observe UI
   - Record: Second transcription works? (PASS/FAIL)
   - Check temp directory again
   - Record: Second temp file also cleaned up? (PASS/FAIL)

6. ERROR HANDLING TEST:
   - Temporarily rename whisper model file
   - Drag new audio file into Reaper
   - Record: Shows error message instead of crashing? (PASS/FAIL)
   - Check temp directory
   - Record: Temp file cleaned up even on failure? (PASS/FAIL)
   - Restore model file

Document all results in VERIFIER_RESULT.md under "Runtime Verification" section.

Include screenshots or screen recording if possible (optional).

================================================================================
IMPLEMENTER INSTRUCTIONS
================================================================================

IMPLEMENTER ROLE - READ CAREFULLY:

You are the IMPLEMENTER. Your job is to:
1. Copy AudioExtractor.h/cpp from PROMPTS/MISSIONS/ to Source/transcription/
2. Modify VoxScriptDocumentController.h/cpp per specification above
3. Modify ScriptView.cpp for UI connection (minor changes)
4. Update CHANGELOG.md
5. Write IMPLEMENTER_RESULT.md
6. STOP - do not run builds, do not verify, do not continue

PROCESS:
1. Copy PROMPTS/MISSIONS/AudioExtractor.h â†’ Source/transcription/AudioExtractor.h
2. Copy PROMPTS/MISSIONS/AudioExtractor.cpp â†’ Source/transcription/AudioExtractor.cpp
3. Add MelechDSP copyright headers to both files
4. Modify VoxScriptDocumentController.h (add AudioExtractor member, cleanupTempFile())
5. Modify VoxScriptDocumentController.cpp:
   - Remove FIXME comments from didAddAudioSource()
   - Implement audio extraction + transcription triggering
   - Update transcriptionComplete() to cleanup temp file
   - Update transcriptionFailed() to cleanup temp file
   - Remove FIXME comments from doCreatePlaybackRegion()
   - Implement cleanupTempFile() method
6. Modify ScriptView.cpp (add timer polling, update paint())
7. Update CHANGELOG.md with Phase III Task 1 completion
8. Write IMPLEMENTER_RESULT.md (see template below)
9. STOP

DO NOT:
- Run build
- Test in DAW
- Verify acceptance criteria
- Fix issues found during implementation (document instead)
- Continue after writing result file
- Modify WhisperEngine or VoxSequence
- Add features beyond scope

IMPLEMENTER_RESULT.md TEMPLATE:

```markdown
# IMPLEMENTER RESULT - PHASE_III_ARA_AUDIO_EXTRACTION_001

## Agent Info
- Role: IMPLEMENTER
- Model: [Your model name]
- Execution time: [Start time] to [End time]

## Summary
[2-3 sentence summary of what was implemented]

## Files Modified
- Source/ara/VoxScriptDocumentController.h: [description]
- Source/ara/VoxScriptDocumentController.cpp: [description]
- Source/ui/ScriptView.cpp: [description]
- CHANGELOG.md: [description]

## Files Created
- Source/transcription/AudioExtractor.h: [description]
- Source/transcription/AudioExtractor.cpp: [description]

## FIXME Comments Removed
- VoxScriptDocumentController.cpp lines 74-90: [confirmation]
- VoxScriptDocumentController.cpp lines 119-138: [confirmation]

## Issues Encountered
[List any problems, ambiguities, or concerns discovered during implementation]
[If none, write "None"]

## Deviations from Spec
[List any intentional deviations from CURRENT_MISSION.txt]
[If none, write "None"]

## Implementation Notes
[Any important details about the implementation approach]

## STOP Confirmation
I have completed code changes and am now STOPPING.
I did NOT run build or verification.
Passing to VERIFIER role.
```

================================================================================
VERIFIER INSTRUCTIONS
================================================================================

VERIFIER ROLE - READ CAREFULLY:

You are the VERIFIER. Your job is to:
1. Read CURRENT_MISSION.txt (this file)
2. Read IMPLEMENTER_RESULT.md
3. Audit file changes against scope
4. Run build command
5. Perform runtime verification steps (6 tests)
6. Evaluate ALL 35 acceptance criteria
7. Write VERIFIER_RESULT.md
8. Write merged LAST_RESULT.md
9. STOP - do not modify code, do not fix issues

PROCESS:
1. Check IMPLEMENTER_RESULT.md exists and is complete
2. List all files modified by IMPLEMENTER
3. Verify no forbidden files were touched (especially WhisperEngine/VoxSequence)
4. Verify FIXME comments removed from VoxScriptDocumentController.cpp
5. Run build: `cd build-Debug && ninja -v`
6. Document build result (SUCCESS/FAILURE)
7. If build SUCCESS, perform 6 runtime verification tests
8. Evaluate each acceptance criterion: PASS/FAIL/SKIP
9. Write VERIFIER_RESULT.md (see template below)
10. Merge IMPLEMENTER + VERIFIER results into LAST_RESULT.md
11. STOP

DO NOT:
- Modify code to fix issues
- Suggest fixes in verification result
- Continue after writing results
- Make "small tweaks" to pass criteria

VERIFIER_RESULT.md TEMPLATE:

```markdown
# VERIFIER RESULT - PHASE_III_ARA_AUDIO_EXTRACTION_001

## Agent Info
- Role: VERIFIER
- Model: [Your model name]
- Execution time: [Start time] to [End time]

## Scope Audit
Files modified (should match SCOPE):
- [List each file with line count delta]

Files NOT in scope but modified (should be empty):
- [List any violations, or write "None"]

Forbidden files touched (should be empty):
- [List any violations, or write "None"]

FIXME comments removed:
- VoxScriptDocumentController.cpp lines 74-90: [YES/NO]
- VoxScriptDocumentController.cpp lines 119-138: [YES/NO]

Scope compliance: [PASS/FAIL]

## Build Result
Command: cd build-Debug && ninja -v
Result: [SUCCESS/FAILURE]

Build output (first/last 20 lines):
```
[Paste output]
```

Build compliance: [PASS/FAIL]

## Acceptance Criteria Evaluation

[AC-1] Build completes without errors: [PASS/FAIL]
[AC-2] No new warnings: [PASS/FAIL]
...
[AC-35] CHANGELOG.md updated: [PASS/FAIL]

Summary: X/35 PASS, Y/35 FAIL, Z/35 SKIP

## Runtime Verification

### Test 1: Clean Start
- Environment clean: [PASS/FAIL]
- Model exists: [PASS/FAIL]

### Test 2: Plugin Load
- Loads without crash: [PASS/FAIL]

### Test 3: Auto-Transcription
- Shows "Extracting audio...": [PASS/FAIL]
- Shows "Transcribing: X%": [PASS/FAIL]
- Transcription text appears: [PASS/FAIL]

### Test 4: Temp File Cleanup
- Temp files deleted: [PASS/FAIL]

### Test 5: Multi-File
- Second transcription works: [PASS/FAIL]
- Second temp file cleaned: [PASS/FAIL]

### Test 6: Error Handling
- Error message shown: [PASS/FAIL]
- Temp file cleaned on error: [PASS/FAIL]

Runtime summary: X/12 tests PASS

## Issues Found
[List any issues discovered during verification]
[If none, write "None"]

## STOP Confirmation
I have completed verification and am now STOPPING.
I did NOT modify any code.
Results written to LAST_RESULT.md.
```

LAST_RESULT.md TEMPLATE:

```markdown
# MISSION RESULT - PHASE_III_ARA_AUDIO_EXTRACTION_001

## Mission Status
[SUCCESS/FAILURE]

## Summary
[Combined 2-3 sentence summary from both agents]

## Agent Execution
- IMPLEMENTER: [model name], [execution time]
- VERIFIER: [model name], [execution time]

## Implementation Summary
[From IMPLEMENTER_RESULT.md - key changes]

## Verification Summary
- Scope compliance: [PASS/FAIL]
- Build result: [SUCCESS/FAILURE]
- Acceptance criteria: X/35 PASS, Y/35 FAIL, Z/35 SKIP
- Runtime verification: X/12 tests PASS
- FIXME comments removed: [YES/NO]

## Key Achievements
[If SUCCESS, list what now works:]
- Automatic transcription triggering when audio added
- Temp file extraction and cleanup
- End-to-end workflow functional

## Issues
[Merged list from both agents]

## Outcome
[If SUCCESS: "Mission APPROVED - Phase III Task 1 COMPLETE. Ready for Task 2 (text editing)."]
[If FAILURE: "Mission REJECTED - create new mission to address failures"]

## STOP Confirmations
- IMPLEMENTER: Stopped after code changes âœ“
- VERIFIER: Stopped after verification âœ“
```

================================================================================
STOP RULE
================================================================================

IMPLEMENTER must STOP after writing IMPLEMENTER_RESULT.md.
VERIFIER must STOP after writing VERIFIER_RESULT.md and LAST_RESULT.md.

NO EXCEPTIONS.
NO "JUST ONE MORE THING".
NO FIXES AFTER STOPPING.

If issues found: Document and STOP. ARCHITECT will decide next steps.

================================================================================
REFERENCE FILES
================================================================================

The complete, production-ready AudioExtractor implementation exists in:

  PROMPTS/MISSIONS/AudioExtractor.h
  PROMPTS/MISSIONS/AudioExtractor.cpp

These files are the result of extensive research by Gemini 2.0 Flash Pro and
contain the correct ARA API usage patterns validated against JUCE documentation.

IMPLEMENTER: Use these files as-is. Do NOT rewrite from scratch.

Key sections to review:
- AudioExtractor.h: Full class interface with documentation
- AudioExtractor.cpp lines 1-50: getTempDirectory() and setup
- AudioExtractor.cpp lines 51-200: extractToTempWAV() implementation
- AudioExtractor.cpp: Thread-safe ARAAudioSourceReader usage
- AudioExtractor.cpp: Downmix â†’ Resample â†’ Write pipeline

================================================================================
SUCCESS CRITERIA SUMMARY
================================================================================

Mission succeeds if:
âœ“ All 35 acceptance criteria PASS
âœ“ Build completes successfully
âœ“ Scope compliance: No forbidden files modified
âœ“ FIXME comments removed from VoxScriptDocumentController.cpp
âœ“ Runtime tests: 12/12 PASS (automatic transcription works end-to-end)
âœ“ Temp files cleaned up properly
âœ“ Both agents STOPPED as required

Mission fails if:
âœ— Any acceptance criterion FAILS
âœ— Build errors
âœ— Scope violations (especially WhisperEngine/VoxSequence modifications)
âœ— FIXME comments still present
âœ— Runtime crashes or transcription doesn't trigger
âœ— Temp file leaks
âœ— Agents did not STOP

================================================================================
CHANGELOG ENTRY TEMPLATE
================================================================================

Add to CHANGELOG.md:

```markdown
## Phase III: Task 1 - Automatic Transcription (Completed - 2026-01-21)

### Added
- **AudioExtractor Class**: Converts ARA audio to whisper-ready WAV files
  - Thread-safe extraction using juce::ARAAudioSourceReader
  - Automatic downmix to mono (average all channels)
  - Automatic resample to 16kHz (Lagrange interpolation)
  - Chunk-based processing (low memory footprint)
  - Output: 16-bit PCM WAV optimized for whisper.cpp
  
- **Automatic Transcription Triggering**:
  - Transcription starts automatically when audio added to DAW
  - No manual intervention required
  - didAddAudioSource() callback integration
  - Progress updates visible in UI
  
- **Temporary File Management**:
  - Automatic temp WAV file creation
  - Unique filenames (UUID-based, no collisions)
  - Cleanup after transcription success
  - Cleanup after transcription failure
  - No temp file leaks

### Modified
- **VoxScriptDocumentController**:
  - Added AudioExtractor member
  - Implemented automatic extraction + transcription in didAddAudioSource()
  - Added cleanupTempFile() for lifecycle management
  - Removed FIXME comments from Phase II (lines 74-90, 119-138)
  
- **ScriptView**:
  - Added timer-based status polling (temporary Phase III solution)
  - Improved paint() for better transcription display
  - Status updates trigger automatic repaints

### Technical Details
- Extraction performance: ~5 seconds for 30-second audio (varies by CPU)
- Downmix before resample: 50% CPU savings vs resample-then-downmix
- Thread safety: Local ARAAudioSourceReader prevents Steinberg glitches
- Temp file location: System temp directory (/tmp on macOS)
- No audio thread allocations (RT-safety preserved)

### Known Limitations (Phase III Task 1)
- Timer-based UI updates (proper observer pattern in Phase IV)
- Sequential processing only (no queue for multiple files yet)
- No extraction progress indicator (extraction is fast, not critical)
- No cancellation support (Phase IV feature)

### What Now Works End-to-End
âœ… User drags audio into DAW â†’ Automatic extraction â†’ Automatic transcription â†’ Text appears in UI
âœ… No manual steps required
âœ… Temp files cleaned up automatically
âœ… Multiple files work sequentially
âœ… Error handling graceful (no crashes)

**Next:** Phase III Task 2 - Text editing and VoxEditList
```

================================================================================
END OF MISSION SPECIFICATION
================================================================================

This mission file is the SINGLE SOURCE OF TRUTH for Phase III Task 1.

All implementation decisions must reference this document.
All verification steps must follow this document.
All scope questions are answered by this document.

If this document is ambiguous or incomplete:
â†’ STOP
â†’ Document the ambiguity in result file
â†’ ARCHITECT will clarify and create new mission

DO NOT PROCEED if anything is unclear.
DO NOT GUESS at specifications.
DO NOT ADD features beyond this scope.

SPECIAL NOTE: The AudioExtractor.h/.cpp files already exist in PROMPTS/MISSIONS/
and are production-ready. Use them as-is. Do NOT rewrite from scratch.

Good luck, agents. Execute with precision. ðŸŽ¯
